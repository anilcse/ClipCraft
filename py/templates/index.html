<!DOCTYPE html>
<html>
<head>
    <title>ClipCraft - Video Processor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Scrollbar */
        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: #1A1D24;
            border-radius: 9999px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: #3A3D46;
            border-radius: 9999px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: #454B57;
        }
    </style>
</head>
<body class="bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-[#1A1D24] via-[#1F1815] to-[#141517] min-h-screen flex flex-col">
    <!-- Update background elements with more cricket iconography -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none" style="z-index: -1">
        <!-- Cricket Bat -->
        <div class="absolute -top-20 -right-20 w-[600px] h-[600px] opacity-[0.08] rotate-[30deg]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <!-- Handle -->
                <rect x="45" y="5" width="10" height="35" fill="none" stroke="currentColor" stroke-width="2"/>
                <!-- Handle Grip -->
                <path d="M45 5 L55 5 L55 40 L45 40 Z" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="2,2"/>
                <!-- Blade -->
                <path d="M35 40 L65 40 L68 85 L32 85 Z" fill="none" stroke="currentColor" stroke-width="2"/>
                <!-- Blade Details -->
                <path d="M38 45 L62 45" stroke="currentColor" stroke-width="1"/>
                <path d="M37 55 L63 55" stroke="currentColor" stroke-width="1"/>
                <path d="M36 65 L64 65" stroke="currentColor" stroke-width="1"/>
                <path d="M35 75 L65 75" stroke="currentColor" stroke-width="1"/>
            </svg>
        </div>

        <!-- Cricket Ball with Detailed Seam -->
        <div class="absolute -top-10 -left-10 w-[400px] h-[400px] opacity-[0.08]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <circle cx="50" cy="50" r="35" fill="none" stroke="currentColor" stroke-width="3"/>
                <path d="M25 50 Q 50 20, 75 50" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M25 50 Q 50 80, 75 50" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M35 40 Q 50 35, 65 40" fill="none" stroke="currentColor" stroke-width="1"/>
                <path d="M35 60 Q 50 65, 65 60" fill="none" stroke="currentColor" stroke-width="1"/>
            </svg>
        </div>

        <!-- Cricket Stumps and Bails -->
        <div class="absolute -bottom-20 left-20 w-[500px] h-[500px] opacity-[0.08] rotate-[-12deg]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <!-- Stumps -->
                <line x1="35" y1="20" x2="35" y2="80" stroke="currentColor" stroke-width="5"/>
                <line x1="50" y1="20" x2="50" y2="80" stroke="currentColor" stroke-width="5"/>
                <line x1="65" y1="20" x2="65" y2="80" stroke="currentColor" stroke-width="5"/>
                <!-- Bails -->
                <rect x="33" y="20" width="34" height="3" fill="none" stroke="currentColor" stroke-width="2"/>
                <rect x="33" y="17" width="34" height="3" fill="none" stroke="currentColor" stroke-width="2"/>
            </svg>
        </div>

        <!-- Cricket Helmet -->
        <div class="absolute -bottom-20 -right-10 w-[500px] h-[500px] opacity-[0.08] rotate-12">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <!-- Helmet Shell -->
                <path d="M25 50 C 25 30, 75 30, 75 50 L 75 75 L 25 75 Z" fill="none" stroke="currentColor" stroke-width="3"/>
                <!-- Grill -->
                <path d="M30 50 L70 50" stroke="currentColor" stroke-width="2"/>
                <path d="M30 55 L70 55" stroke="currentColor" stroke-width="2"/>
                <path d="M30 60 L70 60" stroke="currentColor" stroke-width="2"/>
                <path d="M30 65 L70 65" stroke="currentColor" stroke-width="2"/>
                <path d="M30 70 L70 70" stroke="currentColor" stroke-width="2"/>
                <!-- Visor -->
                <path d="M25 45 C 25 35, 75 35, 75 45" fill="none" stroke="currentColor" stroke-width="3"/>
            </svg>
        </div>

        <!-- Cricket Gloves -->
        <div class="absolute top-1/3 -right-10 w-[300px] h-[300px] opacity-[0.08] rotate-45">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <path d="M30 20 L70 20 L65 60 L35 60 Z" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M35 60 L30 80 L70 80 L65 60" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M40 30 L60 30" stroke="currentColor" stroke-width="1"/>
                <path d="M38 40 L62 40" stroke="currentColor" stroke-width="1"/>
                <path d="M36 50 L64 50" stroke="currentColor" stroke-width="1"/>
            </svg>
        </div>

        <!-- Cricket Pads -->
        <div class="absolute top-1/2 -left-10 w-[400px] h-[400px] opacity-[0.08] rotate-[-30deg]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <path d="M35 10 L65 10 L70 80 L30 80 Z" fill="none" stroke="currentColor" stroke-width="3"/>
                <path d="M40 20 L60 20" stroke="currentColor" stroke-width="2"/>
                <path d="M38 40 L62 40" stroke="currentColor" stroke-width="2"/>
                <path d="M36 60 L64 60" stroke="currentColor" stroke-width="2"/>
                <path d="M45 15 L55 75" stroke="currentColor" stroke-width="2"/>
            </svg>
        </div>
    </div>

    <!-- Header -->
    <header class="bg-gradient-to-b from-[#0A1119] to-[#1A1D24] border-b border-[#2A2D36]/50 backdrop-blur-lg shadow-lg">
        <div class="container max-w-6xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-lg">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                    </div>
            <div>
                        <span class="text-2xl font-bold bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent">ClipCraft</span>
                        <p class="text-xs text-gray-400">Professional Video Processing</p>
            </div>
                </div>
                <div class="text-sm font-medium text-gray-400 bg-[#1A1D24] px-4 py-2 rounded-lg border border-[#2A2D36]/50">
                    Beta Version
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow">
        <div class="container max-w-7xl mx-auto px-4 py-8">
            <!-- Error Alert Container -->
            <div id="errorAlert" class="hidden">
                <!-- Error content -->
            </div>
            
            <form id="videoForm" class="bg-[#1A1D24]/60 border-2 border-[#2A2D36] rounded-3xl shadow-2xl p-8 mb-8">
                <div class="flex space-x-8">
                    <!-- Left Side: Form -->
                    <div class="w-1/2 space-y-6">
                        <!-- YouTube URL Section -->
                        <div class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                            <label class="block text-base font-semibold text-gray-200 mb-3">YouTube URL</label>
                            <input type="text" id="youtubeUrl" name="url" required
                                oninput="onUrlChange(this.value)"
                                onpaste="setTimeout(() => onUrlChange(this.value), 100)"
                                class="w-full px-4 py-3 bg-[#1A1D24] border-2 border-[#3A3D46] text-white rounded-xl 
                                       focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 
                                       placeholder-gray-500 transition-all text-sm">
                        </div>

                        <!-- Segments Section -->
                        <div class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                            <div class="flex items-center justify-between mb-3">
            <div>
                                    <label class="block text-base font-semibold text-gray-200">Video Segments</label>
                                    <p class="text-xs text-gray-400 mt-1">Click "Capture Time" or manually set timestamps in (HH:MM:SS) format</p>
                                </div>
                                <button type="button" onclick="addSegment()"
                                    class="text-xs px-3 py-1.5 bg-[#2A2D36] text-gray-200 rounded-lg hover:bg-[#3A3D46] 
                                           border border-[#3A3D46] shadow-sm transition-all">
                                    Add Segment
                                </button>
                            </div>
                            <div class="relative">
                                <div id="segmentsList" class="space-y-2 min-h-[168px] max-h-[calc(100vh-42rem)] overflow-y-auto pr-2
                                                             scrollbar-thin scrollbar-thumb-[#3A3D46] scrollbar-track-[#1A1D24] 
                                                             scrollbar-thumb-rounded-full scrollbar-track-rounded-full">
                                    <div id="segmentsPlaceholder" class="flex items-center justify-center h-[168px] text-gray-400 text-sm border-2 border-dashed border-[#2A2D36] rounded-xl">
                                        Your video segments will appear here
                                    </div>
                                </div>
                            </div>
            </div>
            
                        <!-- Video and Audio Options Section -->
                        <div class="flex gap-6 w-[200%] -mr-8">
                            <!-- Video Options -->
                            <div class="w-1/3 bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                                <div class="space-y-4">
                                    <label class="block text-base font-semibold text-gray-200">Video Options</label>
                                    <p class="text-xs text-gray-400">Additional processing options</p>
                                    <label class="flex items-center space-x-3 cursor-pointer group">
                                        <input type="checkbox" name="slow_motion" class="hidden peer">
                                        <div class="w-11 h-6 bg-[#2A2D36] rounded-full peer-checked:bg-blue-500 
                                                    after:content-[''] after:absolute after:top-0.5 after:left-0.5 
                                                    after:bg-white after:border-gray-300 after:border after:rounded-full 
                                                    after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-5 
                                                    relative transition-colors"></div>
                                        <span class="text-sm text-gray-400 group-hover:text-gray-300 transition-colors">Slow Motion</span>
                </label>
                                </div>
            </div>

                            <!-- Audio Selection -->
                            <div class="w-2/3 bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                                <label class="block text-base font-semibold text-gray-200 mb-4">Background Audio</label>
                                <div class="overflow-x-auto pb-4">
                                    <div id="audioOptions" class="flex space-x-4 min-w-0">
                                        <!-- Audio options will be loaded here -->
                                    </div>
                                </div>
                            </div>
                        </div>
            </div>

                    <!-- Right Side: Video Preview -->
                    <div class="w-1/2 space-y-6">
                        <div id="previewSection" class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                            <!-- Placeholder when no video -->
                            <div class="flex items-center justify-center h-[300px] text-gray-400 text-sm border-2 border-dashed border-[#2A2D36] rounded-xl">
                                <div class="text-center">
                                    <svg class="w-12 h-12 text-gray-500 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                                              d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                    </svg>
                                    <p>Your video preview will appear here</p>
                                    <p class="text-xs text-gray-500 mt-1">Enter a YouTube URL to get started</p>
                                </div>
                            </div>
                            <div class="hidden" id="previewContent">
                                <label class="block text-base font-semibold text-gray-200 mb-3">Video Preview</label>
                                <div class="rounded-xl overflow-hidden border-2 border-[#2A2D36] bg-[#1A1D24] shadow-xl">
                                    <div id="player" class="w-full aspect-video"></div>
                                </div>
                                <!-- Capture Time Button -->
                                <div class="flex justify-center mt-4">
                                    <button type="button" id="captureTimeBtn" onclick="captureTime()" 
                                        class="px-6 py-2 bg-gradient-to-r from-[#2A2D36] to-[#3A3D46] text-white rounded-lg
                                               hover:from-[#3A3D46] hover:to-[#454B57] 
                                               text-sm font-medium shadow-md transition-all
                                               border-2 border-[#3A3D46] hover:border-[#454B57]
                                               hover:-translate-y-0.5 hover:shadow-lg">
                                        <span class="flex items-center space-x-2">
                                            <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                      d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                            </svg>
                                            <span>Capture Time</span>
                                        </span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Hidden input for crop ranges -->
                <input type="hidden" name="crop_ranges" value="">

                <!-- Add Process Video button at the bottom of the form -->
                <div class="mt-8 flex justify-center">
            <button type="submit" id="submitBtn"
                        class="w-1/2 px-8 py-4 bg-gradient-to-r from-[#3B82F6] via-[#1D4ED8] to-[#7C3AED] text-white rounded-xl 
                               hover:from-[#60A5FA] hover:via-[#2563EB] hover:to-[#8B5CF6]
                               focus:outline-none focus:ring-2 focus:ring-blue-500/50 
                               disabled:opacity-50 disabled:cursor-not-allowed 
                               font-medium transition-all duration-300 ease-in-out
                               flex items-center justify-center space-x-2 
                               shadow-lg shadow-blue-500/20 
                               hover:shadow-xl hover:shadow-blue-500/30 
                               hover:-translate-y-0.5
                               text-base tracking-wide">
                        <span id="submitBtnText" class="font-semibold">Process Video</span>
            </button>
                </div>
        </form>

        <!-- Active Task List -->
            <div id="activeTasksContainer" class="hidden">
                <div class="border-2 border-[#2A2D36] bg-[#1A1D24]/60 rounded-2xl shadow-xl p-8 mb-8 backdrop-blur-xl">
                    <h2 class="text-xl font-bold text-gray-100 mb-6">Active Tasks</h2>
                    <div id="tasksList" class="space-y-6"></div>
                </div>
        </div>

        <!-- Task History -->
            <div id="historyContainer" class="hidden">
                <div class="border-2 border-[#2A2D36] bg-[#1A1D24]/60 rounded-2xl shadow-xl p-8 backdrop-blur-xl">
                    <h2 class="text-xl font-bold text-gray-100 mb-6">Task History</h2>
                    <div id="tasksHistory" class="space-y-6"></div>
        </div>
    </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gradient-to-t from-[#0A1119] to-[#1A1D24] border-t border-[#2A2D36]/50 backdrop-blur-lg">
        <div class="container max-w-6xl mx-auto px-4 py-6">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-6">
                    <span class="text-sm text-gray-400">© 2024 ClipCraft</span>
                    <a href="#" class="text-sm text-gray-400 hover:text-white transition-colors">About</a>
                    <a href="#" class="text-sm text-gray-400 hover:text-white transition-colors">Contact</a>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="text-sm text-gray-400">Made with</span>
                    <svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" />
                    </svg>
                    <span class="text-sm text-gray-400">for cricketers</span>
                </div>
        </div>
    </div>
    </footer>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // Add user ID management at the start of your script
        let userId;

        // Function to generate random user ID
        function generateUserId() {
            return 'user_' + Math.random().toString(36).substr(2, 9);
        }

        // Function to get or create user ID
        function getUserId() {
            let storedUserId = localStorage.getItem('clipcraft_user_id');
            if (!storedUserId) {
                storedUserId = generateUserId();
                localStorage.setItem('clipcraft_user_id', storedUserId);
            }
            return storedUserId;
        }

        // Initialize user ID when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Get user ID
            userId = getUserId();
            
            // Add validation to YouTube URL input
            const urlInput = document.getElementById('youtubeUrl');
            if (urlInput) addInputValidation(urlInput);
            
            // Add validation to existing segment inputs
            document.querySelectorAll('.segment-item input[type="text"]').forEach(addInputValidation);

            // Load audio options
            loadAudioOptions();
        });

        // Initialize variables
        let player;
        let currentFocusedInput = null;
        let activeSegmentIndex = null;
        let lastFocusedInput = null;
        let lastFocusTime = 0;
        let nextInputToUpdate = null;

        // Add audio-related variables
        let audioPreview = null;
        let currentlyPlaying = null;
        let hasInteracted = false;

        // YouTube player initialization
        function onYouTubeIframeAPIReady() {
            // Player will be initialized when URL is entered
        }

        // Handle URL changes
        function onUrlChange(url) {
            const videoId = extractVideoId(url);
            if (videoId) {
                if (player) {
                    player.destroy();
                }
                
                // Show preview content and hide placeholder
                const previewContent = document.getElementById('previewContent');
                const placeholder = previewContent.previousElementSibling;
                previewContent.classList.remove('hidden');
                placeholder.classList.add('hidden');
                
                // Initialize player
                player = new YT.Player('player', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'controls': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });
            } else {
                // Show placeholder and hide preview content
                const previewContent = document.getElementById('previewContent');
                const placeholder = previewContent.previousElementSibling;
                previewContent.classList.add('hidden');
                placeholder.classList.remove('hidden');
            }
        }

        // Update focus tracking
        document.addEventListener('focusin', function(e) {
            if (e.target.tagName === 'INPUT' && 
                e.target.type === 'text' && 
                e.target.closest('.segment-item')) {
                lastFocusedInput = e.target;
                lastFocusTime = Date.now();
                nextInputToUpdate = e.target;
                highlightNextInput();
                updateCaptureButtonText();
            }
        });

        // Update click handler
        document.addEventListener('click', function(e) {
            // If clicking capture time button, don't reset focus
            if (e.target.closest('#captureTimeBtn')) return;
            
            // If clicking a segment input, update tracking
            if (e.target.tagName === 'INPUT' && 
                e.target.type === 'text' && 
                e.target.closest('.segment-item')) {
                lastFocusedInput = e.target;
                lastFocusTime = Date.now();
                nextInputToUpdate = e.target;
                highlightNextInput();
                return;
            }
            
            // If clicking anywhere else, reset everything
            if (!e.target.closest('.segment-item')) {
                lastFocusedInput = null;
                lastFocusTime = 0;
                nextInputToUpdate = findNextEmptyInput(document.querySelectorAll('.segment-item'));
                highlightNextInput();
            }
        });

        // Update highlightNextInput function
        function highlightNextInput() {
            // Remove existing highlights
            document.querySelectorAll('.input-highlight').forEach(el => {
                el.classList.remove('input-highlight', 'ring-2', 'ring-green-500', 'ring-opacity-50');
            });

            // If we have a focused input from last 5 seconds, highlight it
            if (lastFocusedInput && (Date.now() - lastFocusTime < 5000)) {
                lastFocusedInput.classList.add('input-highlight', 'ring-2', 'ring-green-500', 'ring-opacity-50');
            }
            // Otherwise highlight the next input to update
            else if (nextInputToUpdate) {
                nextInputToUpdate.classList.add('input-highlight', 'ring-2', 'ring-green-500', 'ring-opacity-50');
            }
        }

        // Update captureTime function to handle segment indices correctly
        function captureTime() {
            if (!player) return;
            
            const currentTime = player.getCurrentTime();
            const segments = Array.from(document.querySelectorAll('.segment-item'));
            
            // If no segments exist or all segments are filled, create new one
            if (segments.length === 0 || !hasEmptyInputs(segments)) {
                // First clear any placeholder
                const segmentsList = document.getElementById('segmentsList');
                segmentsList.innerHTML = '';  // Clear the placeholder
                
                // Add new segment
                addSegment();
                
                // Get the new segment and update its start time
                const newSegment = document.querySelector('.segment-item:last-child');
                const startInput = newSegment.querySelector('input[placeholder="Start Time"]');
                startInput.value = formatTime(currentTime);
                startInput.dispatchEvent(new Event('change'));
                
                // Set up next input
                nextInputToUpdate = newSegment.querySelector('input[placeholder="End Time"]');
                lastFocusedInput = nextInputToUpdate;
                lastFocusTime = Date.now();
                
                updateCropRanges();
                highlightNextInput();
                updateCaptureButtonText();
                return;
            }
            
            // If we have a focused input from last 5 seconds, use that
            if (lastFocusedInput && (Date.now() - lastFocusTime < 5000)) {
                lastFocusedInput.value = formatTime(currentTime);
                lastFocusedInput.dispatchEvent(new Event('change'));
                
                // Set next input based on current input
                if (lastFocusedInput.placeholder === "Start Time") {
                    nextInputToUpdate = lastFocusedInput.closest('.segment-item').querySelector('input[placeholder="End Time"]');
                } else {
                    const nextEmptyInput = findNextEmptyInput(segments);
                    if (nextEmptyInput) {
                        nextInputToUpdate = nextEmptyInput;
                    } else {
                        addSegment();
                        nextInputToUpdate = document.querySelector('.segment-item:last-child input[placeholder="Start Time"]');
                    }
                }
                lastFocusedInput = nextInputToUpdate;
                lastFocusTime = Date.now();
            } else {
                // Find first empty input and update it
                nextInputToUpdate = findNextEmptyInput(segments);
                if (nextInputToUpdate) {
                    nextInputToUpdate.value = formatTime(currentTime);
                    nextInputToUpdate.dispatchEvent(new Event('change'));
                    
                    // Set up next input
                    if (nextInputToUpdate.placeholder === "Start Time") {
                        nextInputToUpdate = nextInputToUpdate.closest('.segment-item').querySelector('input[placeholder="End Time"]');
                    } else {
                        const nextEmptyInput = findNextEmptyInput(segments);
                        if (nextEmptyInput) {
                            nextInputToUpdate = nextEmptyInput;
                        } else {
                            addSegment();
                            nextInputToUpdate = document.querySelector('.segment-item:last-child input[placeholder="Start Time"]');
                        }
                    }
                    lastFocusedInput = nextInputToUpdate;
                    lastFocusTime = Date.now();
                }
            }
            
            updateCropRanges();
            highlightNextInput();
            updateCaptureButtonText();
        }

        // Update updateCaptureButtonText function for consistent formatting
        function updateCaptureButtonText() {
            const captureBtn = document.getElementById('captureTimeBtn');
            if (!captureBtn) return;

            const buttonSpan = captureBtn.querySelector('span:last-child');
            if (!buttonSpan) return;

            const segments = document.querySelectorAll('.segment-item');
            let buttonText = 'Capture Time';

            // If we have a focused input from last 5 seconds, use that
            if (lastFocusedInput && (Date.now() - lastFocusTime < 5000)) {
                const segment = lastFocusedInput.closest('.segment-item');
                const segmentIndex = Array.from(segments).indexOf(segment) + 1;
                const isStartTime = lastFocusedInput.placeholder === "Start Time";
                buttonText = `Capture Clip-${segmentIndex} ${isStartTime ? 'Start Time' : 'End Time'}`;
            }
            // If we have a next input to update, use that
            else if (nextInputToUpdate) {
                const segment = nextInputToUpdate.closest('.segment-item');
                const segmentIndex = Array.from(segments).indexOf(segment) + 1;
                const isStartTime = nextInputToUpdate.placeholder === "Start Time";
                buttonText = `Capture Clip-${segmentIndex} ${isStartTime ? 'Start Time' : 'End Time'}`;
            }
            // If no segments exist or all segments are filled
            else if (segments.length === 0) {
                buttonText = 'Capture Clip-1 Start Time';
            }
            // Find first empty input
            else {
                const nextEmpty = findNextEmptyInput(segments);
                if (nextEmpty) {
                    const segment = nextEmpty.closest('.segment-item');
                    const segmentIndex = Array.from(segments).indexOf(segment) + 1;
                    const isStartTime = nextEmpty.placeholder === "Start Time";
                    buttonText = `Capture Clip-${segmentIndex} ${isStartTime ? 'Start Time' : 'End Time'}`;
                } else {
                    buttonText = `Capture Clip-${segments.length + 1} Start Time`;
                }
            }

            buttonSpan.textContent = buttonText;
        }

        // Update addSegment function to hide placeholder
        function addSegment() {
            const segmentsList = document.getElementById('segmentsList');
            const placeholder = document.getElementById('segmentsPlaceholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            const segmentIndex = segmentsList.children.length;
            
            const segmentHtml = `
                <div class="segment-item flex items-center gap-2 p-3 bg-[#1A1D24]/80 
                            transition-all w-full backdrop-blur-lg border-b border-[#2A2D36] last:border-b-0
                            hover:bg-[#2A2D36]/40"
                     onclick="handleSegmentClick(${segmentIndex}, event)">
                    <div class="flex-1 flex items-center gap-2 max-w-[85%]">
                        <span class="segment-number text-gray-400 text-sm font-medium min-w-[60px]">Clip ${segmentIndex + 1}</span>
                        <input type="text" 
                            class="w-[120px] px-3 py-2 bg-[#1A1D24] border border-[#3A3D46] text-white rounded-lg
                                   focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 
                                   text-sm transition-all placeholder-gray-500"
                            placeholder="Start Time"
                            onchange="updateSegmentTime(${segmentIndex}, 'start', this.value)">
                        
                        <span class="text-gray-400 text-sm">to</span>
                        
                        <input type="text" 
                            class="w-[120px] px-3 py-2 bg-[#1A1D24] border border-[#3A3D46] text-white rounded-lg
                                   focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 
                                   text-sm transition-all placeholder-gray-500"
                            placeholder="End Time"
                            onchange="updateSegmentTime(${segmentIndex}, 'end', this.value)">
                    </div>

                    <div class="flex gap-1 ml-auto">
                        <button type="button" onclick="previewSegment(${segmentIndex}, event)"
                            class="p-2 text-blue-400 hover:bg-[#2A2D36] rounded-lg transition-all">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                    </svg>
                        </button>
                        <button type="button" onclick="removeSegment(${segmentIndex}, event)"
                            class="p-2 text-red-400 hover:bg-[#2A2D36] rounded-lg transition-all z-10">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                        </button>
                    </div>
                </div>
            `;
            
            segmentsList.insertAdjacentHTML('beforeend', segmentHtml);
            updateSegmentNumbers();
            
            // Set focus to first empty input in new segment
            const newSegment = segmentsList.lastElementChild;
            const firstInput = newSegment.querySelector('input[placeholder="Start Time"]');
            if (firstInput) {
                nextInputToUpdate = firstInput;
                lastFocusedInput = firstInput;
                lastFocusTime = Date.now();
                highlightNextInput();
            }
            
            updateCropRanges();
            updateCaptureButtonText();
        }

        // Add function to update segment numbers
        function updateSegmentNumbers() {
            const segments = document.querySelectorAll('.segment-item');
            segments.forEach((segment, index) => {
                const numberSpan = segment.querySelector('.segment-number');
                if (numberSpan) {
                    numberSpan.textContent = `Clip ${index + 1}`;
                }
            });
        }

        // Update removeSegment function to handle empty segments correctly
        function removeSegment(index, event) {
            // Stop event propagation immediately
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            // Get all segments
            const segments = Array.from(document.querySelectorAll('.segment-item'));
            
            // Get the segment to remove by its DOM position
            const segmentToRemove = segments[index];
            if (!segmentToRemove) return;
            
            // Check if this segment had focus
            const hadFocusedInput = (lastFocusedInput && segmentToRemove.contains(lastFocusedInput)) || 
                                   (nextInputToUpdate && segmentToRemove.contains(nextInputToUpdate));
            
            // Remove the segment
            segmentToRemove.remove();
            
            // Update remaining segments
            const remainingSegments = Array.from(document.querySelectorAll('.segment-item'));
            
            // Reset focus states before updating indices
            lastFocusedInput = null;
            lastFocusTime = 0;
            nextInputToUpdate = null;
            
            // Update indices and handlers for remaining segments
            remainingSegments.forEach((segment, idx) => {
                // Update segment number
                const numberSpan = segment.querySelector('.segment-number');
                if (numberSpan) {
                    numberSpan.textContent = `Clip ${idx + 1}`;
                }
                
                // Update all handlers with new index
                segment.setAttribute('onclick', `handleSegmentClick(${idx}, event)`);
                
                const removeBtn = segment.querySelector('button[onclick^="removeSegment"]');
                if (removeBtn) {
                    removeBtn.setAttribute('onclick', `removeSegment(${idx}, event)`);
                }
                
                const previewBtn = segment.querySelector('button[onclick^="previewSegment"]');
                if (previewBtn) {
                    previewBtn.setAttribute('onclick', `previewSegment(${idx}, event)`);
                }
                
                segment.querySelectorAll('input').forEach(input => {
                    const type = input.placeholder === "Start Time" ? 'start' : 'end';
                    input.setAttribute('onchange', `updateSegmentTime(${idx}, '${type}', this.value)`);
                });
            });
            
            // Show placeholder if no segments left
            if (remainingSegments.length === 0) {
                const placeholder = document.getElementById('segmentsPlaceholder');
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
            } else {
                // Find next empty input in remaining segments
                nextInputToUpdate = findNextEmptyInput(remainingSegments);
            }
            
            updateCropRanges();
            updateCaptureButtonText();
        }

        // Update preview function
        function previewSegment(index, event) {
            event.stopPropagation();
            if (!player) return;

            const segment = document.querySelectorAll('.segment-item')[index];
            const startInput = segment.querySelector('input[placeholder="Start Time"]');
            const endInput = segment.querySelector('input[placeholder="End Time"]');
            
            const startTime = timeToSeconds(startInput.value);
            if (startTime !== null) {
                player.seekTo(startTime);
                player.playVideo();
            }
        }

        // Add helper function to check for empty inputs
        function hasEmptyInputs(segments) {
            for (const segment of segments) {
                const startInput = segment.querySelector('input[placeholder="Start Time"]');
                const endInput = segment.querySelector('input[placeholder="End Time"]');
                if (!startInput.value || !endInput.value) {
                    return true;
                }
            }
            return false;
        }

        // Update formatTime function
        function formatTime(seconds) {
            return new Date(seconds * 1000).toISOString().substr(11, 8);
        }

        // Update updateCropRanges function
        function updateCropRanges() {
            const segmentsList = document.getElementById('segmentsList');
            if (!segmentsList) return;

            const cropRangesInput = document.querySelector('input[name="crop_ranges"]');
            if (!cropRangesInput) return;

            const segments = Array.from(segmentsList.children);
            const ranges = segments.map(segment => {
                const start = segment.querySelector('input[placeholder="Start Time"]')?.value || '';
                const end = segment.querySelector('input[placeholder="End Time"]')?.value || '';
                return start && end ? `${start}-${end}` : '';
            }).filter(range => range).join(' ');
            
            cropRangesInput.value = ranges;
        }

        // Update activateSegment function
        function activateSegment(index) {
            const segment = document.querySelectorAll('.segment-item')[index];
            segment.classList.add('ring-2', 'ring-blue-500', 'ring-opacity-50');
        }

        // Update deactivateSegment function
        function deactivateSegment(index) {
            const segment = document.querySelectorAll('.segment-item')[index];
            segment.classList.remove('ring-2', 'ring-blue-500', 'ring-opacity-50');
        }

        // Update handleSegmentClick function
        function handleSegmentClick(index, event) {
            event.preventDefault();
            event.stopPropagation();
            
            if (activeSegmentIndex === index) {
                deactivateSegment(index);
                activeSegmentIndex = null;
            } else {
                if (activeSegmentIndex !== null) {
                    deactivateSegment(activeSegmentIndex);
                }
                activateSegment(index);
                activeSegmentIndex = index;
            }
        }

        // Update updateSegmentTime function
        function updateSegmentTime(index, type, value) {
            updateCropRanges();
        }

        // Update extractVideoId function
        function extractVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        // Update onPlayerStateChange function with proper checks
        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING && activeSegmentIndex !== null && activeSegmentIndex >= 0) {
                const segments = document.querySelectorAll('.segment-item');
                if (segments.length > activeSegmentIndex) {
                    const segment = segments[activeSegmentIndex];
                    const endTimeInput = segment.querySelector('input[placeholder="End Time"]');
                    if (endTimeInput && endTimeInput.value) {
                        const endTime = timeToSeconds(endTimeInput.value);
                        if (endTime !== null) {
                            // Check current time periodically
                            const timeChecker = setInterval(() => {
                                if (!player) {
                                    clearInterval(timeChecker);
                                    return;
                                }
                                const currentTime = player.getCurrentTime();
                                if (currentTime >= endTime) {
                                    player.pauseVideo();
                                    clearInterval(timeChecker);
                                }
                            }, 100);
                        }
                    }
                }
            }
        }

        // Update onPlayerReady function - remove automatic segment creation
        function onPlayerReady(event) {
            event.target.playVideo();
        }

        // Update form submission handler to show tasks on same page
        document.getElementById('videoForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Validate form
            clearErrors();
            let hasErrors = false;

            // Validate YouTube URL
            const urlInput = document.getElementById('youtubeUrl');
            if (!isValidYoutubeUrl(urlInput.value)) {
                showError(urlInput, 'Please enter a valid YouTube URL');
                hasErrors = true;
            }

            // Validate segments
            const segments = document.querySelectorAll('.segment-item');
            const validSegments = [];
            
            segments.forEach((segment, index) => {
                const startInput = segment.querySelector('input[placeholder="Start Time"]');
                const endInput = segment.querySelector('input[placeholder="End Time"]');
                
                // Skip empty segments
                if (!startInput.value && !endInput.value) {
                    return;
                }
                
                // Validate start time
                if (!startInput.value) {
                    showError(startInput, 'Start time is required');
                    hasErrors = true;
                } else if (!isValidTimestamp(startInput.value)) {
                    showError(startInput, 'Invalid time format (HH:MM:SS or MM:SS)');
                    hasErrors = true;
                }
                
                // Validate end time
                if (!endInput.value) {
                    showError(endInput, 'End time is required');
                    hasErrors = true;
                } else if (!isValidTimestamp(endInput.value)) {
                    showError(endInput, 'Invalid time format (HH:MM:SS or MM:SS)');
                    hasErrors = true;
                }
                
                // If both times are valid, check if end time is after start time
                if (startInput.value && endInput.value && 
                    isValidTimestamp(startInput.value) && isValidTimestamp(endInput.value)) {
                    const startSeconds = timeToSeconds(startInput.value);
                    const endSeconds = timeToSeconds(endInput.value);
                    
                    if (endSeconds <= startSeconds) {
                        showError(endInput, 'End time must be after start time');
                        hasErrors = true;
                    }
                    
                    // Check if video duration is valid
                    if (player && player.getDuration) {
                        const videoDuration = player.getDuration();
                        if (endSeconds > videoDuration) {
                            showError(endInput, 'End time exceeds video duration');
                            hasErrors = true;
                        }
                    }
                    
                    // Add to valid segments if no errors
                    if (!hasErrors) {
                        validSegments.push({
                            start: startInput.value,
                            end: endInput.value
                        });
                    }
                }
            });

            // If no valid segments, show error
            if (validSegments.length === 0) {
                showGlobalError('At least one valid segment is required');
                hasErrors = true;
            }

            if (!hasErrors) {
                try {
                    // Ensure we have a user ID
                    if (!userId) {
                        userId = getUserId();
                    }

                    const formData = new FormData(this);
                    const requestBody = {
                        url: formData.get('url'),
                        crop_ranges: formData.get('crop_ranges'),
                        slow_motion: formData.get('slow_motion') === 'on',
                        user_id: userId,  // Make sure user_id is included
                        audio_url: document.querySelector('input[name="audio_selection"]:checked')?.value
                    };
                    
                    // Show loading state
                    const submitBtn = document.getElementById('submitBtn');
                    const submitBtnText = document.getElementById('submitBtnText');
                    submitBtn.disabled = true;
                    submitBtnText.textContent = 'Processing...';

                    // Submit to API endpoint
                    const response = await fetch('/process-video', {
                    method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                        throw new Error('Failed to process video');
                    }

                    const result = await response.json();
                    
                    // Handle success
                    if (result.task_id) {
                        // Show success message
                        showSuccessMessage('Video processing started successfully!');
                        
                        // Reset form
                        this.reset();
                        
                        // Clear segments
                        document.getElementById('segmentsList').innerHTML = '';
                        
                        // Hide video preview
                        document.getElementById('previewSection').classList.add('hidden');
                        
                        // Show tasks section and update tasks list
                        document.getElementById('activeTasksContainer').classList.remove('hidden');
                        await updateTasksList();
                    } else {
                        throw new Error('No task ID received');
                    }
            } catch (error) {
                    showGlobalError('Failed to process video. Please try again.');
                    console.error('Submission error:', error);
            } finally {
                    // Reset button state
                    const submitBtn = document.getElementById('submitBtn');
                    const submitBtnText = document.getElementById('submitBtnText');
                submitBtn.disabled = false;
                    submitBtnText.textContent = 'Process Video';
                }
            }
        });

        // Add function to show success message
        function showSuccessMessage(message) {
            const errorAlert = document.getElementById('errorAlert');
            errorAlert.className = 'bg-green-500/10 border border-green-500/50 text-green-500 px-4 py-3 rounded-lg mb-4';
            errorAlert.innerHTML = message;
            errorAlert.classList.remove('hidden');
            
            // Hide message after 5 seconds
            setTimeout(() => {
                errorAlert.classList.add('hidden');
            }, 5000);
        }

        // Update the tasks list rendering function
        async function updateTasksList() {
            try {
                // Ensure we have a user ID
                if (!userId) {
                    userId = getUserId();
                }

                const response = await fetch(`/tasks?user_id=${userId}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch tasks');
                }

                const tasks = await response.json();
                
                const tasksList = document.getElementById('tasksList');
                const tasksContainer = document.getElementById('activeTasksContainer');

                if (!tasks || tasks.length === 0) {
                    tasksContainer.classList.add('hidden');
                    return;
                }

                tasksContainer.classList.remove('hidden');
                tasksList.innerHTML = tasks.map(task => `
                    <div class="bg-[#2A2D36]/30 rounded-xl p-4 border border-[#3A3D46]">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-gray-300 text-sm truncate max-w-[200px]">${task.task_id}</span>
                            <span class="text-sm px-2 py-1 rounded-lg ${getStatusClass(task.status)}">
                                ${task.status}
                                </span>
                            </div>
                        <div class="w-full bg-[#1A1D24] rounded-full h-2 mb-3">
                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" 
                                 style="width: ${task.progress}%"></div>
                            </div>
                        <div class="flex items-center justify-between">
                            <div class="text-xs text-gray-400">Progress: ${task.progress}%</div>
                            <div class="flex gap-2">
                                ${task.status === 'Completed' ? `
                                    <a href="/download/${task.task_id}?user_id=${userId}" 
                                       class="px-3 py-1.5 bg-green-500/10 text-green-500 text-xs rounded-lg 
                                              hover:bg-green-500/20 transition-colors flex items-center gap-1">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                        </svg>
                                        <span>Download</span>
                                    </a>
                                ` : ''}
                                ${['Processing', 'Queued'].includes(task.status) ? `
                                    <button onclick="cancelTask('${task.task_id}')"
                                            class="px-3 py-1.5 bg-red-500/10 text-red-500 text-xs rounded-lg 
                                                   hover:bg-red-500/20 transition-colors flex items-center gap-1">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                  d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                        <span>Cancel</span>
                                    </button>
                                ` : ''}
                        </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error updating tasks list:', error);
            }
        }

        // Add function to handle task cancellation
        async function cancelTask(taskId) {
            try {
                const response = await fetch(`/cancel-task/${taskId}?user_id=${userId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    await updateTasksList();
                } else {
                    showGlobalError('Failed to cancel task');
                }
            } catch (error) {
                console.error('Error cancelling task:', error);
                showGlobalError('Failed to cancel task');
            }
        }

        // Add helper function for status classes
        function getStatusClass(status) {
            switch (status.toLowerCase()) {
                case 'completed':
                    return 'bg-green-500/10 text-green-500';
                case 'failed':
                    return 'bg-red-500/10 text-red-500';
                case 'processing':
                    return 'bg-blue-500/10 text-blue-500';
                case 'cancelled':
                    return 'bg-gray-500/10 text-gray-500';
                case 'queued':
                    return 'bg-yellow-500/10 text-yellow-500';
                default:
                    return 'bg-gray-500/10 text-gray-500';
            }
        }

        // Start periodic task updates
        setInterval(updateTasksList, 5000);  // Update every 5 seconds

        // Add timeToSeconds function
        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':').map(Number);
            if (parts.length === 2) {
                return parts[0] * 60 + parts[1];
            }
            return parts[0] * 3600 + parts[1] * 60 + parts[2];
        }

        // Add validation functions
        function isValidYoutubeUrl(url) {
            const pattern = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})$/;
            return pattern.test(url);
        }

        function isValidTimestamp(timestamp) {
            // Accept formats: MM:SS or HH:MM:SS
            const pattern = /^(?:(?:([01]?\d|2[0-3]):)?([0-5]?\d):)?([0-5]?\d)$/;
            return pattern.test(timestamp);
        }

        // Helper functions
        function showError(element, message) {
            // Remove any existing error
            clearError(element);
            
            // Add error styles
            element.classList.add('border-red-500', 'focus:border-red-500', 'focus:ring-red-500/50');
            
            // Add error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'text-red-500 text-xs mt-1';
            errorDiv.textContent = message;
            element.parentNode.appendChild(errorDiv);
        }

        function showGlobalError(message) {
            if (message === 'At least one valid segment is required') {
                const segmentsError = document.getElementById('segmentsError');
                if (segmentsError) {
                    segmentsError.textContent = message;
                    segmentsError.classList.remove('hidden');
                }
            } else {
                const errorAlert = document.getElementById('errorAlert');
                errorAlert.className = 'bg-red-500/10 border border-red-500/50 text-red-500 px-4 py-3 rounded-lg mb-4';
                errorAlert.innerHTML = message;
                errorAlert.classList.remove('hidden');
            }
        }

        function clearError(element) {
            element.classList.remove('border-red-500', 'focus:border-red-500', 'focus:ring-red-500/50');
            const errorDiv = element.parentNode.querySelector('.text-red-500');
            if (errorDiv) {
                errorDiv.remove();
            }
        }

        function clearErrors() {
            document.querySelectorAll('input').forEach(clearError);
            
            const errorAlert = document.getElementById('errorAlert');
            errorAlert.classList.add('hidden');
            errorAlert.innerHTML = '';
            
            const segmentsError = document.getElementById('segmentsError');
            if (segmentsError) {
                segmentsError.classList.add('hidden');
                segmentsError.textContent = '';
            }
        }

        // Update the initial input validation setup
        document.addEventListener('DOMContentLoaded', function() {
            // Add validation to YouTube URL input
            const urlInput = document.getElementById('youtubeUrl');
            if (urlInput) addInputValidation(urlInput);
            
            // Add validation to existing segment inputs
            document.querySelectorAll('.segment-item input[type="text"]').forEach(addInputValidation);
        });

        // Update addInputValidation function to handle both URL and timestamp validations
        function addInputValidation(input) {
            input.addEventListener('change', function() {
                clearError(this);
                
                if (this.id === 'youtubeUrl') {
                    if (!isValidYoutubeUrl(this.value)) {
                        showError(this, 'Please enter a valid YouTube URL');
                    }
                } else if (this.closest('.segment-item') && this.value && !isValidTimestamp(this.value)) {
                    showError(this, 'Invalid time format (HH:MM:SS or MM:SS)');
                }
            });
        }

        // Add findNextEmptyInput function
        function findNextEmptyInput(segments) {
            for (const segment of segments) {
                const startInput = segment.querySelector('input[placeholder="Start Time"]');
                const endInput = segment.querySelector('input[placeholder="End Time"]');
                
                if (!startInput.value) {
                    return startInput;
                }
                if (!endInput.value) {
                    return endInput;
                }
            }
            return null;
        }

        // Update createAudioOption function with square design and audio logo
        function createAudioOption(audio, index) {
            // Array of gradient classes for variety
            const gradients = [
                'from-blue-500/10 via-indigo-500/10 to-purple-500/10',
                'from-purple-500/10 via-pink-500/10 to-rose-500/10',
                'from-emerald-500/10 via-teal-500/10 to-cyan-500/10',
                'from-orange-500/10 via-red-500/10 to-pink-500/10',
                'from-sky-500/10 via-blue-500/10 to-indigo-500/10'
            ];
            
            // Get gradient based on index
            const gradient = gradients[index % gradients.length];
            
            return `
                <div class="flex-shrink-0 audio-option group" data-audio-url="${audio.file}">
                    <label class="block relative">
                        <input type="radio" name="audio_selection" value="${audio.file}"
                               class="absolute opacity-0 w-full h-full cursor-pointer peer">
                        <div class="w-[120px] aspect-square bg-gradient-to-br ${gradient} 
                                   backdrop-blur-xl border border-[#3A3D46] rounded-xl
                                   peer-checked:border-blue-500 peer-checked:bg-blue-500/10
                                   hover:border-white/20 hover:scale-[1.02] 
                                   transition-all duration-300 cursor-pointer
                                   relative overflow-hidden group">
                            
                            <!-- Background Pattern -->
                            <div class="absolute inset-0 opacity-5">
                                <div class="absolute inset-0 bg-gradient-to-br from-white/20 to-transparent"></div>
                            </div>

                            <!-- Audio Logo -->
                            <div class="absolute top-3 left-3 w-8 h-8 bg-white/10 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 text-white/80" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                                          d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
                                </svg>
                            </div>

                            <!-- Content -->
                            <div class="relative h-full p-3 flex flex-col">
                                <div class="flex-grow mt-8">
                                    <div class="text-sm font-medium text-white/90 truncate">${audio.name}</div>
                                    <div class="text-xs text-white/60 mt-0.5">${audio.duration}</div>
                                </div>
                                
                                <!-- Audio Waves -->
                                <div class="audio-waves opacity-0 group-hover:opacity-100 transition-all duration-300 
                                            flex justify-center h-4 mt-auto">
                                    <span class="wave"></span>
                                    <span class="wave"></span>
                                    <span class="wave"></span>
                                    <span class="wave"></span>
                                    <span class="wave"></span>
                                </div>
                            </div>

                            <!-- Selection Indicator -->
                            <div class="absolute top-2 right-2 w-4 h-4 rounded-full border border-white/20
                                       peer-checked:bg-blue-500 peer-checked:border-blue-500
                                       transition-all duration-300"></div>
                        </div>
                    </label>
                </div>
            `;
        }

        // Update the audio waves animation CSS
        const style = document.createElement('style');
        style.textContent = `
            .audio-waves {
                display: flex;
                align-items: center;
                gap: 2px;
            }
            
            .wave {
                display: block;
                width: 2px;
                height: 12px;
                background: white;
                opacity: 0.8;
                animation: wave 1.2s infinite ease-in-out;
                transform-origin: bottom;
                border-radius: 999px;
            }
            
            .wave:nth-child(2) { animation-delay: 0.1s; }
            .wave:nth-child(3) { animation-delay: 0.2s; }
            .wave:nth-child(4) { animation-delay: 0.3s; }
            .wave:nth-child(5) { animation-delay: 0.4s; }
            
            @keyframes wave {
                0%, 100% { transform: scaleY(0.2); }
                50% { transform: scaleY(1); }
            }
            
            .paused .wave {
                animation-play-state: paused;
                opacity: 0.4;
            }

            .audio-option:hover .wave {
                box-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
            }
        `;
        document.head.appendChild(style);

        // Update loadAudioOptions function to pass index to createAudioOption
        async function loadAudioOptions() {
            try {
                const response = await fetch('/api/audio-options');
                if (!response.ok) throw new Error('Failed to fetch audio options');
                
                const audioOptions = await response.json();
                const audioContainer = document.getElementById('audioOptions');
                
                if (audioOptions.length === 0) {
                    audioContainer.innerHTML = '<p class="text-gray-400 text-sm">No audio files available</p>';
                    return;
                }
                
                audioContainer.innerHTML = audioOptions.map((audio, index) => 
                    createAudioOption(audio, index)
                ).join('');
                
                // Add hover handlers
                document.querySelectorAll('.audio-option').forEach(option => {
                    let audioElement = null;
                    let isHovering = false;
                    
                    option.addEventListener('mouseenter', () => {
                        isHovering = true;
                        const audioUrl = option.dataset.audioUrl;
                        if (!audioElement) {
                            audioElement = new Audio(audioUrl);
                            audioElement.addEventListener('ended', () => {
                                if (isHovering) {
                                    audioElement.currentTime = 0;
                                    audioElement.play();
                                }
                            });
                        }
                        audioElement.play();
                        option.querySelector('.audio-waves')?.classList.remove('paused');
                    });
                    
                    option.addEventListener('mouseleave', () => {
                        isHovering = false;
                        if (audioElement) {
                            audioElement.pause();
                            audioElement.currentTime = 0;
                        }
                        option.querySelector('.audio-waves')?.classList.add('paused');
                    });
                });
                
            } catch (error) {
                console.error('Error loading audio options:', error);
            }
        }
    </script>
</body>
</html>
