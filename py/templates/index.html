<!DOCTYPE html>
<html>
<head>
    <title>ClipCraft - Video Processor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Scrollbar */
        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: #1A1D24;
            border-radius: 9999px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: #3A3D46;
            border-radius: 9999px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: #454B57;
        }
    </style>
</head>
<body class="bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-[#1A1D24] via-[#1F1815] to-[#141517] min-h-screen flex flex-col">
    <!-- Update background elements with more cricket iconography -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none" style="z-index: -1">
        <!-- Cricket Bat -->
        <div class="absolute -top-20 -right-20 w-[600px] h-[600px] opacity-[0.08] rotate-[30deg]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <!-- Handle -->
                <rect x="45" y="5" width="10" height="35" fill="none" stroke="currentColor" stroke-width="2"/>
                <!-- Handle Grip -->
                <path d="M45 5 L55 5 L55 40 L45 40 Z" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="2,2"/>
                <!-- Blade -->
                <path d="M35 40 L65 40 L68 85 L32 85 Z" fill="none" stroke="currentColor" stroke-width="2"/>
                <!-- Blade Details -->
                <path d="M38 45 L62 45" stroke="currentColor" stroke-width="1"/>
                <path d="M37 55 L63 55" stroke="currentColor" stroke-width="1"/>
                <path d="M36 65 L64 65" stroke="currentColor" stroke-width="1"/>
                <path d="M35 75 L65 75" stroke="currentColor" stroke-width="1"/>
            </svg>
        </div>

        <!-- Cricket Ball with Detailed Seam -->
        <div class="absolute -top-10 -left-10 w-[400px] h-[400px] opacity-[0.08]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <circle cx="50" cy="50" r="35" fill="none" stroke="currentColor" stroke-width="3"/>
                <path d="M25 50 Q 50 20, 75 50" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M25 50 Q 50 80, 75 50" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M35 40 Q 50 35, 65 40" fill="none" stroke="currentColor" stroke-width="1"/>
                <path d="M35 60 Q 50 65, 65 60" fill="none" stroke="currentColor" stroke-width="1"/>
            </svg>
        </div>

        <!-- Cricket Stumps and Bails -->
        <div class="absolute -bottom-20 left-20 w-[500px] h-[500px] opacity-[0.08] rotate-[-12deg]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <!-- Stumps -->
                <line x1="35" y1="20" x2="35" y2="80" stroke="currentColor" stroke-width="5"/>
                <line x1="50" y1="20" x2="50" y2="80" stroke="currentColor" stroke-width="5"/>
                <line x1="65" y1="20" x2="65" y2="80" stroke="currentColor" stroke-width="5"/>
                <!-- Bails -->
                <rect x="33" y="20" width="34" height="3" fill="none" stroke="currentColor" stroke-width="2"/>
                <rect x="33" y="17" width="34" height="3" fill="none" stroke="currentColor" stroke-width="2"/>
            </svg>
        </div>

        <!-- Cricket Helmet -->
        <div class="absolute -bottom-20 -right-10 w-[500px] h-[500px] opacity-[0.08] rotate-12">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <!-- Helmet Shell -->
                <path d="M25 50 C 25 30, 75 30, 75 50 L 75 75 L 25 75 Z" fill="none" stroke="currentColor" stroke-width="3"/>
                <!-- Grill -->
                <path d="M30 50 L70 50" stroke="currentColor" stroke-width="2"/>
                <path d="M30 55 L70 55" stroke="currentColor" stroke-width="2"/>
                <path d="M30 60 L70 60" stroke="currentColor" stroke-width="2"/>
                <path d="M30 65 L70 65" stroke="currentColor" stroke-width="2"/>
                <path d="M30 70 L70 70" stroke="currentColor" stroke-width="2"/>
                <!-- Visor -->
                <path d="M25 45 C 25 35, 75 35, 75 45" fill="none" stroke="currentColor" stroke-width="3"/>
            </svg>
        </div>

        <!-- Cricket Gloves -->
        <div class="absolute top-1/3 -right-10 w-[300px] h-[300px] opacity-[0.08] rotate-45">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <path d="M30 20 L70 20 L65 60 L35 60 Z" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M35 60 L30 80 L70 80 L65 60" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M40 30 L60 30" stroke="currentColor" stroke-width="1"/>
                <path d="M38 40 L62 40" stroke="currentColor" stroke-width="1"/>
                <path d="M36 50 L64 50" stroke="currentColor" stroke-width="1"/>
            </svg>
        </div>

        <!-- Cricket Pads -->
        <div class="absolute top-1/2 -left-10 w-[400px] h-[400px] opacity-[0.08] rotate-[-30deg]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full text-white">
                <path d="M35 10 L65 10 L70 80 L30 80 Z" fill="none" stroke="currentColor" stroke-width="3"/>
                <path d="M40 20 L60 20" stroke="currentColor" stroke-width="2"/>
                <path d="M38 40 L62 40" stroke="currentColor" stroke-width="2"/>
                <path d="M36 60 L64 60" stroke="currentColor" stroke-width="2"/>
                <path d="M45 15 L55 75" stroke="currentColor" stroke-width="2"/>
            </svg>
        </div>
    </div>

    <!-- Header -->
    <header class="bg-gradient-to-b from-[#0A1119] to-[#1A1D24] border-b border-[#2A2D36]/50 backdrop-blur-lg shadow-lg">
        <div class="container max-w-6xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-lg">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                    </div>
            <div>
                        <span class="text-2xl font-bold bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent">ClipCraft</span>
                        <p class="text-xs text-gray-400">Professional Video Processing</p>
            </div>
                </div>
                <div class="text-sm font-medium text-gray-400 bg-[#1A1D24] px-4 py-2 rounded-lg border border-[#2A2D36]/50">
                    Beta Version
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow">
        <div class="container max-w-7xl mx-auto px-4 py-8">
            <!-- Error Alert Container -->
            <div id="errorAlert" class="hidden">
                <!-- Error content -->
            </div>
            
            <form id="videoForm" class="bg-[#1A1D24]/60 border-2 border-[#2A2D36] rounded-3xl shadow-2xl p-8 mb-8">
                <div class="flex space-x-8">
                    <!-- Left Side: Form -->
                    <div class="w-1/2 space-y-6">
                        <!-- YouTube URL Section -->
                        <div class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                            <label class="block text-base font-semibold text-gray-200 mb-3">YouTube URL</label>
                            <input type="text" id="youtubeUrl" name="url" required
                                oninput="onUrlChange(this.value)"
                                onpaste="setTimeout(() => onUrlChange(this.value), 100)"
                                class="w-full px-4 py-3 bg-[#1A1D24] border-2 border-[#3A3D46] text-white rounded-xl 
                                       focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 
                                       placeholder-gray-500 transition-all text-sm">
                        </div>

                        <!-- Segments Section -->
                        <div class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                            <div class="flex items-center justify-between mb-3">
            <div>
                                    <label class="block text-base font-semibold text-gray-200">Video Segments</label>
                                    <p class="text-xs text-gray-400 mt-1">Click "Capture Time" or manually set timestamps in (HH:MM:SS) format</p>
                                </div>
                                <button type="button" onclick="addSegment()"
                                    class="text-xs px-3 py-1.5 bg-[#2A2D36] text-gray-200 rounded-lg hover:bg-[#3A3D46] 
                                           border border-[#3A3D46] shadow-sm transition-all">
                                    Add Segment
                                </button>
                            </div>
                            <div class="relative">
                                <div id="segmentsList" class="space-y-2 min-h-[168px] max-h-[calc(100vh-42rem)] overflow-y-auto pr-2
                                                             scrollbar-thin scrollbar-thumb-[#3A3D46] scrollbar-track-[#1A1D24] 
                                                             scrollbar-thumb-rounded-full scrollbar-track-rounded-full">
                                    <!-- Segments will be added here -->
                                </div>
                            </div>
            </div>
            
                        <!-- Audio Selection Section -->
                        <div class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6">
                            <div class="flex items-center justify-between">
                                <div>
                                    <label class="block text-base font-semibold text-gray-200">Video Options</label>
                                    <p class="text-xs text-gray-400 mt-1">Additional processing options</p>
                                </div>
                                <label class="flex items-center space-x-3 cursor-pointer group">
                                    <input type="checkbox" name="slow_motion" class="hidden peer">
                                    <div class="w-11 h-6 bg-[#2A2D36] rounded-full peer-checked:bg-blue-500 
                                                after:content-[''] after:absolute after:top-0.5 after:left-0.5 
                                                after:bg-white after:border-gray-300 after:border after:rounded-full 
                                                after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-5 
                                                relative transition-colors"></div>
                                    <span class="text-sm text-gray-400 group-hover:text-gray-300 transition-colors">Slow Motion</span>
                </label>
                            </div>
            </div>

                <div class="bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6 space-y-4">
                    <label class="block text-base font-semibold text-gray-200">Background Audio (optional)</label>
                    <div class="grid grid-cols-6 gap-4 overflow-x-auto pb-4">
                        <div id="audioOptions" class="col-span-6 flex space-x-4">
                            <!-- Audio options will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>

                    <!-- Right Side: Video Preview -->
                    <div class="w-1/2">
                        <div id="previewSection" class="hidden bg-[#1A1D24]/40 rounded-2xl border border-[#2A2D36] p-6 sticky top-8">
                            <label class="block text-base font-semibold text-gray-200 mb-3">Video Preview</label>
                            <div class="rounded-xl overflow-hidden border-2 border-[#2A2D36] bg-[#1A1D24] shadow-xl">
                                <div id="player" class="w-full aspect-video"></div>
                            </div>
                            <!-- Capture Time Button -->
                            <div class="flex justify-center mt-4">
                                <button type="button" id="captureTimeBtn" onclick="captureTime()" 
                                    class="px-6 py-2 bg-gradient-to-r from-[#2A2D36] to-[#3A3D46] text-white rounded-lg
                                           hover:from-[#3A3D46] hover:to-[#454B57] 
                                           text-sm font-medium shadow-md transition-all
                                           border-2 border-[#3A3D46] hover:border-[#454B57]
                                           hover:-translate-y-0.5 hover:shadow-lg">
                                    <span class="flex items-center space-x-2">
                                        <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                  d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                        </svg>
                                        <span>Capture Time</span>
                                    </span>
                                </button>
                            </div>
                        </div>
                    </div>
            </div>

                <!-- Hidden input for crop ranges -->
                <input type="hidden" name="crop_ranges" value="">

                <!-- Add Process Video button at the bottom of the form -->
                <div class="mt-8 flex justify-center">
            <button type="submit" id="submitBtn"
                        class="w-1/2 px-8 py-4 bg-gradient-to-r from-[#3B82F6] via-[#1D4ED8] to-[#7C3AED] text-white rounded-xl 
                               hover:from-[#60A5FA] hover:via-[#2563EB] hover:to-[#8B5CF6]
                               focus:outline-none focus:ring-2 focus:ring-blue-500/50 
                               disabled:opacity-50 disabled:cursor-not-allowed 
                               font-medium transition-all duration-300 ease-in-out
                               flex items-center justify-center space-x-2 
                               shadow-lg shadow-blue-500/20 
                               hover:shadow-xl hover:shadow-blue-500/30 
                               hover:-translate-y-0.5
                               text-base tracking-wide">
                        <span id="submitBtnText" class="font-semibold">Process Video</span>
            </button>
                </div>
        </form>

        <!-- Active Task List -->
            <div id="activeTasksContainer" class="hidden">
                <div class="border-2 border-[#2A2D36] bg-[#1A1D24]/60 rounded-2xl shadow-xl p-8 mb-8 backdrop-blur-xl">
                    <h2 class="text-xl font-bold text-gray-100 mb-6">Active Tasks</h2>
                    <div id="tasksList" class="space-y-6"></div>
                </div>
        </div>

        <!-- Task History -->
            <div id="historyContainer" class="hidden">
                <div class="border-2 border-[#2A2D36] bg-[#1A1D24]/60 rounded-2xl shadow-xl p-8 backdrop-blur-xl">
                    <h2 class="text-xl font-bold text-gray-100 mb-6">Task History</h2>
                    <div id="tasksHistory" class="space-y-6"></div>
        </div>
    </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gradient-to-t from-[#0A1119] to-[#1A1D24] border-t border-[#2A2D36]/50 backdrop-blur-lg">
        <div class="container max-w-6xl mx-auto px-4 py-6">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-6">
                    <span class="text-sm text-gray-400">© 2024 ClipCraft</span>
                    <a href="#" class="text-sm text-gray-400 hover:text-white transition-colors">About</a>
                    <a href="#" class="text-sm text-gray-400 hover:text-white transition-colors">Contact</a>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="text-sm text-gray-400">Made with</span>
                    <svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" />
                    </svg>
                    <span class="text-sm text-gray-400">for cricketers</span>
                </div>
        </div>
    </div>
    </footer>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // Add user ID management at the start of your script
        let userId;

        // Function to generate random user ID
        function generateUserId() {
            return 'user_' + Math.random().toString(36).substr(2, 9);
        }

        // Function to get or create user ID
        function getUserId() {
            let storedUserId = localStorage.getItem('clipcraft_user_id');
            if (!storedUserId) {
                storedUserId = generateUserId();
                localStorage.setItem('clipcraft_user_id', storedUserId);
            }
            return storedUserId;
        }

        // Initialize user ID when page loads
        document.addEventListener('DOMContentLoaded', function() {
            userId = getUserId();
        });

        // Initialize variables
        let player;
        let currentFocusedInput = null;
        let activeSegmentIndex = null;
        let lastFocusedInput = null;
        let lastFocusTime = 0;
        let nextInputToUpdate = null;

        // Add audio-related variables
        let audioPreview = null;
        let currentlyPlaying = null;
        let hasInteracted = false;

        // YouTube player initialization
        function onYouTubeIframeAPIReady() {
            // Player will be initialized when URL is entered
        }

        // Handle URL changes
        function onUrlChange(url) {
            const videoId = extractVideoId(url);
            if (videoId) {
                if (player) {
                    player.destroy();
                }
                
                // Show preview section
                document.getElementById('previewSection').classList.remove('hidden');
                
                // Initialize player
                player = new YT.Player('player', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'controls': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });
            }
        }

        // Update focus tracking
        document.addEventListener('focusin', function(e) {
            if (e.target.tagName === 'INPUT' && 
                e.target.type === 'text' && 
                e.target.closest('.segment-item')) {
                lastFocusedInput = e.target;
                lastFocusTime = Date.now();
                nextInputToUpdate = e.target;
                highlightNextInput();
                updateCaptureButtonText();
            }
        });

        // Update click handler
        document.addEventListener('click', function(e) {
            // If clicking capture time button, don't reset focus
            if (e.target.closest('#captureTimeBtn')) return;
            
            // If clicking a segment input, update tracking
            if (e.target.tagName === 'INPUT' && 
                e.target.type === 'text' && 
                e.target.closest('.segment-item')) {
                lastFocusedInput = e.target;
                lastFocusTime = Date.now();
                nextInputToUpdate = e.target;
                highlightNextInput();
                updateCaptureButtonText();
                return;
            }
            
            // If clicking anywhere else, reset everything
            if (!e.target.closest('.segment-item')) {
                lastFocusedInput = null;
                lastFocusTime = 0;
                nextInputToUpdate = findNextEmptyInput(document.querySelectorAll('.segment-item'));
                highlightNextInput();
            }
        });

        // Update highlightNextInput function
        function highlightNextInput() {
            // Remove existing highlights
            document.querySelectorAll('.input-highlight').forEach(el => {
                el.classList.remove('input-highlight', 'ring-2', 'ring-green-500', 'ring-opacity-50');
            });

            // If we have a focused input from last 5 seconds, highlight it
            if (lastFocusedInput && (Date.now() - lastFocusTime < 5000)) {
                lastFocusedInput.classList.add('input-highlight', 'ring-2', 'ring-green-500', 'ring-opacity-50');
            }
            // Otherwise highlight the next input to update
            else if (nextInputToUpdate) {
                nextInputToUpdate.classList.add('input-highlight', 'ring-2', 'ring-green-500', 'ring-opacity-50');
            }
        }

        // Update captureTime function to handle inputs immediately
        function captureTime() {
            if (!player) return;
            
            const currentTime = player.getCurrentTime();
            const segments = document.querySelectorAll('.segment-item');
            
            // If no segments exist, create one and update immediately
            if (segments.length === 0) {
                addSegment();
                const newSegment = document.querySelector('.segment-item:last-child');
                const startInput = newSegment.querySelector('input[placeholder="Start Time"]');
                startInput.value = formatTime(currentTime);
                startInput.dispatchEvent(new Event('change'));
                nextInputToUpdate = newSegment.querySelector('input[placeholder="End Time"]');
                lastFocusedInput = nextInputToUpdate;
                lastFocusTime = Date.now();
                updateCropRanges();
                highlightNextInput();
                updateCaptureButtonText();
                return;
            }

            // If we have a focused input from last 5 seconds, use that
            if (lastFocusedInput && (Date.now() - lastFocusTime < 5000)) {
                lastFocusedInput.value = formatTime(currentTime);
                lastFocusedInput.dispatchEvent(new Event('change'));
                
                // Set next input based on current input
                if (lastFocusedInput.placeholder === "Start Time") {
                    nextInputToUpdate = lastFocusedInput.closest('.segment-item').querySelector('input[placeholder="End Time"]');
                } else {
                    if (!hasEmptyInputs(segments)) {
                        addSegment();
                        nextInputToUpdate = document.querySelector('.segment-item:last-child input[placeholder="Start Time"]');
                    } else {
                        nextInputToUpdate = findNextEmptyInput(segments);
                    }
                }
                lastFocusedInput = nextInputToUpdate;
                lastFocusTime = Date.now();
            } else {
                // Find first empty input and update it immediately
                nextInputToUpdate = findNextEmptyInput(segments);
                if (nextInputToUpdate) {
                    nextInputToUpdate.value = formatTime(currentTime);
                    nextInputToUpdate.dispatchEvent(new Event('change'));
                    
                    // Set up next input
                    if (nextInputToUpdate.placeholder === "Start Time") {
                        nextInputToUpdate = nextInputToUpdate.closest('.segment-item').querySelector('input[placeholder="End Time"]');
                    } else {
                        if (!hasEmptyInputs(segments)) {
                            addSegment();
                            nextInputToUpdate = document.querySelector('.segment-item:last-child input[placeholder="Start Time"]');
                        } else {
                            nextInputToUpdate = findNextEmptyInput(segments);
                        }
                    }
                    lastFocusedInput = nextInputToUpdate;
                    lastFocusTime = Date.now();
                }
            }
            
            updateCropRanges();
            highlightNextInput();
            updateCaptureButtonText();
        }

        // Update updateCaptureButtonText function for consistent formatting
        function updateCaptureButtonText() {
            const captureBtn = document.getElementById('captureTimeBtn');
            if (!captureBtn) return;

            const buttonSpan = captureBtn.querySelector('span:last-child');
            if (!buttonSpan) return;

            const segments = document.querySelectorAll('.segment-item');
            let buttonText = 'Capture Time';

            // If we have a focused input from last 5 seconds, use that
            if (lastFocusedInput && (Date.now() - lastFocusTime < 5000)) {
                const segment = lastFocusedInput.closest('.segment-item');
                const segmentIndex = Array.from(segments).indexOf(segment) + 1;
                const isStartTime = lastFocusedInput.placeholder === "Start Time";
                buttonText = `Capture Clip-${segmentIndex} ${isStartTime ? 'Start Time' : 'End Time'}`;
            }
            // If we have a next input to update, use that
            else if (nextInputToUpdate) {
                const segment = nextInputToUpdate.closest('.segment-item');
                const segmentIndex = Array.from(segments).indexOf(segment) + 1;
                const isStartTime = nextInputToUpdate.placeholder === "Start Time";
                buttonText = `Capture Clip-${segmentIndex} ${isStartTime ? 'Start Time' : 'End Time'}`;
            }
            // If no segments exist or all segments are filled
            else if (segments.length === 0) {
                buttonText = 'Capture Clip-1 Start Time';
            }
            // Find first empty input
            else {
                const nextEmpty = findNextEmptyInput(segments);
                if (nextEmpty) {
                    const segment = nextEmpty.closest('.segment-item');
                    const segmentIndex = Array.from(segments).indexOf(segment) + 1;
                    const isStartTime = nextEmpty.placeholder === "Start Time";
                    buttonText = `Capture Clip-${segmentIndex} ${isStartTime ? 'Start Time' : 'End Time'}`;
                } else {
                    buttonText = `Capture Clip-${segments.length + 1} Start Time`;
                }
            }

            buttonSpan.textContent = buttonText;
        }

        // Update addSegment function to handle immediate focus
        function addSegment() {
            const segmentsList = document.getElementById('segmentsList');
            const segmentIndex = segmentsList.children.length;
            
            const segmentHtml = `
                <div class="segment-item flex items-center gap-2 p-3 bg-[#1A1D24]/80 
                            transition-all w-full backdrop-blur-lg border-b border-[#2A2D36] last:border-b-0
                            hover:bg-[#2A2D36]/40"
                     onclick="handleSegmentClick(${segmentIndex}, event)">
                    <div class="flex-1 flex items-center gap-2 max-w-[85%]">
                        <span class="segment-number text-gray-400 text-sm font-medium min-w-[60px]">Clip ${segmentIndex + 1}</span>
                        <input type="text" 
                            class="w-[120px] px-3 py-2 bg-[#1A1D24] border border-[#3A3D46] text-white rounded-lg
                                   focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 
                                   text-sm transition-all placeholder-gray-500"
                            placeholder="Start Time"
                            onchange="updateSegmentTime(${segmentIndex}, 'start', this.value)">
                        
                        <span class="text-gray-400 text-sm">to</span>
                        
                        <input type="text" 
                            class="w-[120px] px-3 py-2 bg-[#1A1D24] border border-[#3A3D46] text-white rounded-lg
                                   focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 
                                   text-sm transition-all placeholder-gray-500"
                            placeholder="End Time"
                            onchange="updateSegmentTime(${segmentIndex}, 'end', this.value)">
                    </div>

                    <div class="flex gap-1 ml-auto">
                        <button type="button" onclick="previewSegment(${segmentIndex}, event)"
                            class="p-2 text-blue-400 hover:bg-[#2A2D36] rounded-lg transition-all">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                    </svg>
                        </button>
                        <button type="button" onclick="removeSegment(${segmentIndex}, event)"
                            class="p-2 text-red-400 hover:bg-[#2A2D36] rounded-lg transition-all">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                        </button>
                    </div>
                </div>
            `;
            
            segmentsList.insertAdjacentHTML('beforeend', segmentHtml);
            updateSegmentNumbers();
            
            // Set focus to first empty input in new segment
            const newSegment = segmentsList.lastElementChild;
            const firstInput = newSegment.querySelector('input[placeholder="Start Time"]');
            if (firstInput) {
                nextInputToUpdate = firstInput;
                lastFocusedInput = firstInput;
                lastFocusTime = Date.now();
                highlightNextInput();
            }
            
            updateCropRanges();
            updateCaptureButtonText();
        }

        // Add function to update segment numbers
        function updateSegmentNumbers() {
            const segments = document.querySelectorAll('.segment-item');
            segments.forEach((segment, index) => {
                const numberSpan = segment.querySelector('.segment-number');
                if (numberSpan) {
                    numberSpan.textContent = `Clip ${index + 1}`;
                }
            });
        }

        // Update removeSegment function
        function removeSegment(index, event) {
            event.stopPropagation();
            const segments = document.querySelectorAll('.segment-item');
            if (index >= segments.length) return;  // Guard against invalid index
            
            const removedSegment = segments[index];
            if (!removedSegment) return;  // Guard against missing segment
            
            // Check if the removed segment had the focused input
            const hadFocusedInput = (lastFocusedInput && removedSegment.contains(lastFocusedInput)) || 
                                   (nextInputToUpdate && removedSegment.contains(nextInputToUpdate));
            
            // Remove the segment
            removedSegment.remove();
            
            // Update segment numbers
            updateSegmentNumbers();
            
            // If we removed a segment with focus, find new input to focus
            if (hadFocusedInput) {
                lastFocusedInput = null;
                lastFocusTime = 0;
                const remainingSegments = document.querySelectorAll('.segment-item');
                nextInputToUpdate = findNextEmptyInput(remainingSegments);
                highlightNextInput();
            }
            
            // If no segments left, reset button text
            if (segments.length <= 1) {
                const buttonSpan = document.getElementById('captureTimeBtn')?.querySelector('span:last-child');
                if (buttonSpan) {
                    buttonSpan.textContent = 'Capture Clip-1 Start Time';
                }
            }
            
            updateCropRanges();
            updateCaptureButtonText();
        }

        // Update preview function
        function previewSegment(index, event) {
            event.stopPropagation();
            if (!player) return;

            const segment = document.querySelectorAll('.segment-item')[index];
            const startInput = segment.querySelector('input[placeholder="Start Time"]');
            const endInput = segment.querySelector('input[placeholder="End Time"]');
            
            const startTime = timeToSeconds(startInput.value);
            if (startTime !== null) {
                player.seekTo(startTime);
                player.playVideo();
            }
        }

        // Add helper function to check for empty inputs
        function hasEmptyInputs(segments) {
            for (const segment of segments) {
                const startInput = segment.querySelector('input[placeholder="Start Time"]');
                const endInput = segment.querySelector('input[placeholder="End Time"]');
                if (!startInput.value || !endInput.value) {
                    return true;
                }
            }
            return false;
        }

        // Update formatTime function
        function formatTime(seconds) {
            return new Date(seconds * 1000).toISOString().substr(11, 8);
        }

        // Update updateCropRanges function
        function updateCropRanges() {
            const segmentsList = document.getElementById('segmentsList');
            if (!segmentsList) return;

            const cropRangesInput = document.querySelector('input[name="crop_ranges"]');
            if (!cropRangesInput) return;

            const segments = Array.from(segmentsList.children);
            const ranges = segments.map(segment => {
                const start = segment.querySelector('input[placeholder="Start Time"]')?.value || '';
                const end = segment.querySelector('input[placeholder="End Time"]')?.value || '';
                return start && end ? `${start}-${end}` : '';
            }).filter(range => range).join(' ');
            
            cropRangesInput.value = ranges;
        }

        // Update activateSegment function
        function activateSegment(index) {
            const segment = document.querySelectorAll('.segment-item')[index];
            segment.classList.add('ring-2', 'ring-blue-500', 'ring-opacity-50');
        }

        // Update deactivateSegment function
        function deactivateSegment(index) {
            const segment = document.querySelectorAll('.segment-item')[index];
            segment.classList.remove('ring-2', 'ring-blue-500', 'ring-opacity-50');
        }

        // Update handleSegmentClick function
        function handleSegmentClick(index, event) {
            event.preventDefault();
            event.stopPropagation();
            
            if (activeSegmentIndex === index) {
                deactivateSegment(index);
                activeSegmentIndex = null;
            } else {
                if (activeSegmentIndex !== null) {
                    deactivateSegment(activeSegmentIndex);
                }
                activateSegment(index);
                activeSegmentIndex = index;
            }
        }

        // Update updateSegmentTime function
        function updateSegmentTime(index, type, value) {
            updateCropRanges();
        }

        // Update extractVideoId function
        function extractVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        // Update onPlayerStateChange function with proper checks
        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING && activeSegmentIndex !== null && activeSegmentIndex >= 0) {
                const segments = document.querySelectorAll('.segment-item');
                if (segments.length > activeSegmentIndex) {
                    const segment = segments[activeSegmentIndex];
                    const endTimeInput = segment.querySelector('input[placeholder="End Time"]');
                    if (endTimeInput && endTimeInput.value) {
                        const endTime = timeToSeconds(endTimeInput.value);
                        if (endTime !== null) {
                            // Check current time periodically
                            const timeChecker = setInterval(() => {
                                if (!player) {
                                    clearInterval(timeChecker);
                                    return;
                                }
                                const currentTime = player.getCurrentTime();
                                if (currentTime >= endTime) {
                                    player.pauseVideo();
                                    clearInterval(timeChecker);
                                }
                            }, 100);
                        }
                    }
                }
            }
        }

        // Update onPlayerReady function - remove automatic segment creation
        function onPlayerReady(event) {
            event.target.playVideo();
        }

        // Update form submission handler to show tasks on same page
        document.getElementById('videoForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Validate form
            clearErrors();
            let hasErrors = false;

            // Validate YouTube URL
            const urlInput = document.getElementById('youtubeUrl');
            if (!isValidYoutubeUrl(urlInput.value)) {
                showError(urlInput, 'Please enter a valid YouTube URL');
                hasErrors = true;
            }

            // Validate segments
            const segments = document.querySelectorAll('.segment-item');
            const validSegments = [];
            
            segments.forEach((segment, index) => {
                const startInput = segment.querySelector('input[placeholder="Start Time"]');
                const endInput = segment.querySelector('input[placeholder="End Time"]');
                
                // Skip empty segments
                if (!startInput.value && !endInput.value) {
                    return;
                }
                
                // Validate start time
                if (!startInput.value) {
                    showError(startInput, 'Start time is required');
                    hasErrors = true;
                } else if (!isValidTimestamp(startInput.value)) {
                    showError(startInput, 'Invalid time format (HH:MM:SS or MM:SS)');
                    hasErrors = true;
                }
                
                // Validate end time
                if (!endInput.value) {
                    showError(endInput, 'End time is required');
                    hasErrors = true;
                } else if (!isValidTimestamp(endInput.value)) {
                    showError(endInput, 'Invalid time format (HH:MM:SS or MM:SS)');
                    hasErrors = true;
                }
                
                // If both times are valid, check if end time is after start time
                if (startInput.value && endInput.value && 
                    isValidTimestamp(startInput.value) && isValidTimestamp(endInput.value)) {
                    const startSeconds = timeToSeconds(startInput.value);
                    const endSeconds = timeToSeconds(endInput.value);
                    
                    if (endSeconds <= startSeconds) {
                        showError(endInput, 'End time must be after start time');
                        hasErrors = true;
                    }
                    
                    // Check if video duration is valid
                    if (player && player.getDuration) {
                        const videoDuration = player.getDuration();
                        if (endSeconds > videoDuration) {
                            showError(endInput, 'End time exceeds video duration');
                            hasErrors = true;
                        }
                    }
                    
                    // Add to valid segments if no errors
                    if (!hasErrors) {
                        validSegments.push({
                            start: startInput.value,
                            end: endInput.value
                        });
                    }
                }
            });

            // If no valid segments, show error
            if (validSegments.length === 0) {
                showGlobalError('At least one valid segment is required');
                hasErrors = true;
            }

            if (!hasErrors) {
                try {
                    // Ensure we have a user ID
                    if (!userId) {
                        userId = getUserId();
                    }

                    const formData = new FormData(this);
                    const requestBody = {
                        url: formData.get('url'),
                        crop_ranges: formData.get('crop_ranges'),
                        slow_motion: formData.get('slow_motion') === 'on',
                        user_id: userId,  // Make sure user_id is included
                        audio_url: document.querySelector('input[name="audio_selection"]:checked')?.value
                    };
                    
                    // Show loading state
                    const submitBtn = document.getElementById('submitBtn');
                    const submitBtnText = document.getElementById('submitBtnText');
                    submitBtn.disabled = true;
                    submitBtnText.textContent = 'Processing...';

                    // Submit to API endpoint
                    const response = await fetch('/process-video', {
                    method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                        throw new Error('Failed to process video');
                    }

                    const result = await response.json();
                    
                    // Handle success
                    if (result.task_id) {
                        // Show success message
                        showSuccessMessage('Video processing started successfully!');
                        
                        // Reset form
                        this.reset();
                        
                        // Clear segments
                        document.getElementById('segmentsList').innerHTML = '';
                        
                        // Hide video preview
                        document.getElementById('previewSection').classList.add('hidden');
                        
                        // Show tasks section and update tasks list
                        document.getElementById('activeTasksContainer').classList.remove('hidden');
                        await updateTasksList();
                    } else {
                        throw new Error('No task ID received');
                    }
            } catch (error) {
                    showGlobalError('Failed to process video. Please try again.');
                    console.error('Submission error:', error);
            } finally {
                    // Reset button state
                    const submitBtn = document.getElementById('submitBtn');
                    const submitBtnText = document.getElementById('submitBtnText');
                submitBtn.disabled = false;
                    submitBtnText.textContent = 'Process Video';
                }
            }
        });

        // Add function to show success message
        function showSuccessMessage(message) {
            const errorAlert = document.getElementById('errorAlert');
            errorAlert.className = 'bg-green-500/10 border border-green-500/50 text-green-500 px-4 py-3 rounded-lg mb-4';
            errorAlert.innerHTML = message;
            errorAlert.classList.remove('hidden');
            
            // Hide message after 5 seconds
            setTimeout(() => {
                errorAlert.classList.add('hidden');
            }, 5000);
        }

        // Update the tasks list rendering function
        async function updateTasksList() {
            try {
                // Ensure we have a user ID
                if (!userId) {
                    userId = getUserId();
                }

                const response = await fetch(`/tasks?user_id=${userId}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch tasks');
                }

                const tasks = await response.json();
                
                const tasksList = document.getElementById('tasksList');
                const tasksContainer = document.getElementById('activeTasksContainer');

                if (!tasks || tasks.length === 0) {
                    tasksContainer.classList.add('hidden');
                    return;
                }

                tasksContainer.classList.remove('hidden');
                tasksList.innerHTML = tasks.map(task => `
                    <div class="bg-[#2A2D36]/30 rounded-xl p-4 border border-[#3A3D46]">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-gray-300 text-sm truncate max-w-[200px]">${task.task_id}</span>
                            <span class="text-sm px-2 py-1 rounded-lg ${getStatusClass(task.status)}">
                                ${task.status}
                            </span>
                        </div>
                        <div class="w-full bg-[#1A1D24] rounded-full h-2 mb-3">
                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" 
                                 style="width: ${task.progress}%"></div>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="text-xs text-gray-400">Progress: ${task.progress}%</div>
                            <div class="flex gap-2">
                                ${task.status === 'Completed' ? `
                                    <a href="/download/${task.task_id}?user_id=${userId}" 
                                       class="px-3 py-1.5 bg-green-500/10 text-green-500 text-xs rounded-lg 
                                              hover:bg-green-500/20 transition-colors flex items-center gap-1">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                        </svg>
                                        <span>Download</span>
                                    </a>
                                ` : ''}
                                ${['Processing', 'Queued'].includes(task.status) ? `
                                    <button onclick="cancelTask('${task.task_id}')"
                                            class="px-3 py-1.5 bg-red-500/10 text-red-500 text-xs rounded-lg 
                                                   hover:bg-red-500/20 transition-colors flex items-center gap-1">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                  d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                        <span>Cancel</span>
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error updating tasks list:', error);
            }
        }

        // Add function to handle task cancellation
        async function cancelTask(taskId) {
            try {
                const response = await fetch(`/cancel-task/${taskId}?user_id=${userId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    await updateTasksList();
                } else {
                    showGlobalError('Failed to cancel task');
                }
            } catch (error) {
                console.error('Error cancelling task:', error);
                showGlobalError('Failed to cancel task');
            }
        }

        // Add helper function for status classes
        function getStatusClass(status) {
            switch (status.toLowerCase()) {
                case 'completed':
                    return 'bg-green-500/10 text-green-500';
                case 'failed':
                    return 'bg-red-500/10 text-red-500';
                case 'processing':
                    return 'bg-blue-500/10 text-blue-500';
                case 'cancelled':
                    return 'bg-gray-500/10 text-gray-500';
                case 'queued':
                    return 'bg-yellow-500/10 text-yellow-500';
                default:
                    return 'bg-gray-500/10 text-gray-500';
            }
        }

        // Start periodic task updates
        setInterval(updateTasksList, 5000);  // Update every 5 seconds

        // Add timeToSeconds function
        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':').map(Number);
            if (parts.length === 2) {
                return parts[0] * 60 + parts[1];
            }
            return parts[0] * 3600 + parts[1] * 60 + parts[2];
        }

        // Add validation functions
        function isValidYoutubeUrl(url) {
            const pattern = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})$/;
            return pattern.test(url);
        }

        function isValidTimestamp(timestamp) {
            // Accept formats: MM:SS or HH:MM:SS
            const pattern = /^(?:(?:([01]?\d|2[0-3]):)?([0-5]?\d):)?([0-5]?\d)$/;
            return pattern.test(timestamp);
        }

        // Helper functions
        function showError(element, message) {
            // Remove any existing error
            clearError(element);
            
            // Add error styles
            element.classList.add('border-red-500', 'focus:border-red-500', 'focus:ring-red-500/50');
            
            // Add error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'text-red-500 text-xs mt-1';
            errorDiv.textContent = message;
            element.parentNode.appendChild(errorDiv);
        }

        function showGlobalError(message) {
            const errorAlert = document.getElementById('errorAlert');
            errorAlert.className = 'bg-red-500/10 border border-red-500/50 text-red-500 px-4 py-3 rounded-lg mb-4';
            errorAlert.innerHTML = message;
            errorAlert.classList.remove('hidden');
        }

        function clearError(element) {
            element.classList.remove('border-red-500', 'focus:border-red-500', 'focus:ring-red-500/50');
            const errorDiv = element.parentNode.querySelector('.text-red-500');
            if (errorDiv) {
                errorDiv.remove();
            }
        }

        function clearErrors() {
            // Clear all input errors
            document.querySelectorAll('input').forEach(clearError);
            
            // Clear global error
            const errorAlert = document.getElementById('errorAlert');
            errorAlert.classList.add('hidden');
            errorAlert.innerHTML = '';
        }

        // Update the initial input validation setup
        document.addEventListener('DOMContentLoaded', function() {
            // Add validation to YouTube URL input
            const urlInput = document.getElementById('youtubeUrl');
            if (urlInput) addInputValidation(urlInput);
            
            // Add validation to existing segment inputs
            document.querySelectorAll('.segment-item input[type="text"]').forEach(addInputValidation);
        });

        // Update addInputValidation function to handle both URL and timestamp validations
        function addInputValidation(input) {
            input.addEventListener('change', function() {
                clearError(this);
                
                if (this.id === 'youtubeUrl') {
                    if (!isValidYoutubeUrl(this.value)) {
                        showError(this, 'Please enter a valid YouTube URL');
                    }
                } else if (this.closest('.segment-item') && this.value && !isValidTimestamp(this.value)) {
                    showError(this, 'Invalid time format (HH:MM:SS or MM:SS)');
                }
            });
        }

        // Add findNextEmptyInput function
        function findNextEmptyInput(segments) {
            for (const segment of segments) {
                const startInput = segment.querySelector('input[placeholder="Start Time"]');
                const endInput = segment.querySelector('input[placeholder="End Time"]');
                
                if (!startInput.value) {
                    return startInput;
                }
                if (!endInput.value) {
                    return endInput;
                }
            }
            return null;
        }

        // Add function to load audio options
        async function loadAudioOptions() {
            try {
                const response = await fetch('/api/audio-options');
                if (!response.ok) {
                    throw new Error('Failed to fetch audio options');
                }
                
                const audioOptions = await response.json();
                const audioContainer = document.getElementById('audioOptions');
                
                if (audioOptions.length === 0) {
                    audioContainer.innerHTML = '<p class="text-gray-400 text-sm">No audio files available</p>';
                    return;
                }
                
                audioContainer.innerHTML = audioOptions.map((audio, index) => `
                    <div class="flex-shrink-0">
                        <label class="block relative">
                            <input type="radio" name="audio_selection" value="${audio.file}"
                                   class="absolute opacity-0 w-full h-full cursor-pointer peer">
                            <div class="p-3 bg-[#1A1D24] border-2 border-[#3A3D46] rounded-xl
                                       peer-checked:border-blue-500 peer-checked:bg-blue-500/10
                                       hover:bg-[#2A2D36] transition-all cursor-pointer
                                       min-w-[140px]">
                                <div class="text-sm font-medium text-gray-200 mb-1">${audio.name}</div>
                                <div class="text-xs text-gray-400">${audio.duration}</div>
                            </div>
                        </label>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error loading audio options:', error);
            }
        }

        // Add function to preview audio
        function previewAudio(audioUrl, event) {
            event.preventDefault();
            event.stopPropagation();

            if (audioPreview && currentlyPlaying === audioUrl) {
                stopAudioPreview();
                return;
            }

            stopAudioPreview();
            audioPreview = new Audio(audioUrl);
            currentlyPlaying = audioUrl;
            
            audioPreview.addEventListener('ended', () => {
                stopAudioPreview();
            });

            audioPreview.play().catch(error => {
                console.error('Error playing audio:', error);
                stopAudioPreview();
            });

            // Update play button to show pause icon
            const playButton = event.currentTarget;
            playButton.innerHTML = `
                <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6" />
                </svg>
            `;
        }

        // Add function to stop audio preview
        function stopAudioPreview() {
            if (audioPreview) {
                audioPreview.pause();
                audioPreview.currentTime = 0;
                audioPreview = null;
                currentlyPlaying = null;

                // Reset all play buttons to show play icon
                document.querySelectorAll('.preview-btn').forEach(btn => {
                    btn.innerHTML = `
                        <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                  d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                        </svg>
                    `;
                });
            }
        }

        // Initialize audio options when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadAudioOptions();
            // ... existing DOMContentLoaded code ...
        });

        // Clean up audio when leaving page
        window.addEventListener('beforeunload', () => {
            stopAudioPreview();
        });
    </script>
</body>
</html>
